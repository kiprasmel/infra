#!/usr/bin/env bash
set -euo pipefail

INFRA_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
REMOTE_INFRA_DIR="\$HOME/infra"

### begin dependencies ###

command -v jq >/dev/null 2>&1 || {
    >&2 echo "error: jq is required but not installed."
    >&2 echo "  brew install jq    # macOS"
    >&2 echo "  apt install jq     # debian/ubuntu"
    exit 1
}

### end dependencies ###

### begin config ###

INFRA_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/infra"
INFRA_CONFIG_FILE="$INFRA_CONFIG_DIR/config.json"

config_init() {
    mkdir -p "$INFRA_CONFIG_DIR"
    test -f "$INFRA_CONFIG_FILE" || echo '{}' > "$INFRA_CONFIG_FILE"
}

# config_get <jq_filter>
# reads a value from config; prints nothing if key is missing
config_get() {
    config_init
    jq -r "($1) // empty" "$INFRA_CONFIG_FILE"
}

# config_set <jq_filter> <value>
# sets a value in config (atomic write via tmp file)
config_set() {
    config_init
    local tmp; tmp="$(mktemp)"
    jq "$1 = \$v" --arg v "$2" "$INFRA_CONFIG_FILE" > "$tmp" && mv "$tmp" "$INFRA_CONFIG_FILE"
}

### end config ###

### begin project detection ###

# detect_project
# infers project name from CWD, handling git worktrees.
# for worktrees, --git-common-dir points to the main repo's .git,
# so we dirname that to get the real repo root.
detect_project() {
    local dir
    dir="$(pwd)"

    if command -v git >/dev/null 2>&1 && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        local git_common_dir
        git_common_dir="$(git rev-parse --git-common-dir 2>/dev/null)"
        if test -n "$git_common_dir"; then
            dir="$(dirname "$(readlink -f "$git_common_dir")")"
        fi
    fi

    basename "$dir"
}

# resolve_alias <name>
# checks aliases map in config; returns mapped project name or input unchanged
resolve_alias() {
    local name="$1"
    local mapped
    mapped="$(config_get ".aliases.\"$name\"")"
    if test -n "$mapped"; then
        echo "$mapped"
    else
        echo "$name"
    fi
}

# is_valid_project <name>
# returns 0 if server/<name> exists in the infra repo
is_valid_project() {
    test -d "$INFRA_DIR/server/$1"
}

# resolve_project_dir <project>
# validates project exists and returns its server/ path
resolve_project_dir() {
    local project="$1"
    local project_dir="server/$project"
    test -d "$INFRA_DIR/$project_dir" || {
        >&2 echo "error: project '$project' not found in server/"
        exit 1
    }
    echo "$project_dir"
}

### end project detection ###

### begin remote resolution ###

# resolve_remote <project>
# walks: per-project config -> global default -> error
resolve_remote() {
    local project="$1"
    local remote

    # 1. per-project remote
    remote="$(config_get ".projects.\"$project\".remote")"
    test -n "$remote" && { echo "$remote"; return; }

    # 2. global default
    remote="$(config_get ".default_remote")"
    test -n "$remote" && { echo "$remote"; return; }

    # 3. not found
    >&2 echo "error: no remote for project '$project' and no default_remote set."
    >&2 echo "  infra config set default-remote <remote>"
    >&2 echo "  infra config set remote $project <remote>"
    return 1
}

# save_project_remote <project> <remote>
# persists the remote used for a project into config
save_project_remote() {
    config_set ".projects.\"$1\".remote" "$2"
}

### end remote resolution ###

### begin commands ###

# infra cd [remote] [project]
cmd_cd() {
    local remote="" project=""

    case $# in
        0)
            project="$(resolve_alias "$(detect_project)")"
            remote="$(resolve_remote "$project")"
            ;;
        1)
            local candidate
            candidate="$(resolve_alias "$1")"
            if is_valid_project "$candidate"; then
                project="$candidate"
                remote="$(resolve_remote "$project")"
            else
                remote="$1"
                project="$(resolve_alias "$(detect_project)")"
            fi
            ;;
        2)
            remote="$1"
            project="$(resolve_alias "$2")"
            ;;
        *)
            >&2 echo "usage: infra cd [remote] [project]"
            exit 1
            ;;
    esac

    local project_dir; project_dir="$(resolve_project_dir "$project")"
    save_project_remote "$project" "$remote"

    ssh -t -o LogLevel=ERROR "$remote" "cd $REMOTE_INFRA_DIR/$project_dir && exec \$SHELL -l"
}

# infra exec [script] [args...]
# infra exec [remote] [project] [script] [args...]   (backward compat)
cmd_exec() {
    local remote="" project="" script=""

    if test $# -ge 3 && { is_valid_project "$2" || is_valid_project "$(resolve_alias "$2")"; }; then
        # old format: <remote> <project> <script> [args...]
        remote="$1"; shift
        project="$(resolve_alias "$1")"; shift
        script="$1"; shift
    elif test $# -ge 1; then
        # new format: <script> [args...]
        project="$(resolve_alias "$(detect_project)")"
        remote="$(resolve_remote "$project")"
        script="$1"; shift
    else
        >&2 echo "usage: infra exec [script] [args...]"
        >&2 echo "       infra exec [remote] [project] [script] [args...]"
        exit 1
    fi

    local project_dir; project_dir="$(resolve_project_dir "$project")"
    save_project_remote "$project" "$remote"

    ssh -t -o LogLevel=ERROR "$remote" "\$SHELL -l -c 'cd $REMOTE_INFRA_DIR/$project_dir && ./$script $*'"
}

### end commands ###

case "${1:-}" in
    cd)   shift; cmd_cd "$@" ;;
    exec) shift; cmd_exec "$@" ;;
    *)    echo "usage: infra <cd|exec> <remote> <project> [script] [args...]"; exit 1 ;;
esac
